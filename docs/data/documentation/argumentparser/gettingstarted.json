{"metadata":{"modules":[{"name":"ArgumentParser"}],"role":"article","title":"Getting Started with ArgumentParser","roleHeading":"Article"},"seeAlsoSections":[{"identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp"],"generated":true,"title":"Essentials"}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Overview","text":"Overview","type":"heading"},{"inlineContent":[{"type":"text","text":"This guide walks through building an example command. You’ll learn about the different tools that "},{"code":"ArgumentParser","type":"codeVoice"},{"type":"text","text":" provides for defining a command’s options, customizing the interface, and providing help text for your user."}],"type":"paragraph"},{"anchor":"Adding-ArgumentParser-as-a-Dependency","type":"heading","text":"Adding ArgumentParser as a Dependency","level":2},{"inlineContent":[{"type":"text","text":"Let’s write a tool called "},{"type":"codeVoice","code":"count"},{"text":" that reads an input file, counts the words, and writes the result to an output file.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"First, we need to add "},{"code":"swift-argument-parser","type":"codeVoice"},{"type":"text","text":" as a dependency to our package,"},{"type":"text","text":" "},{"text":"and then include ","type":"text"},{"code":"\"ArgumentParser\"","type":"codeVoice"},{"type":"text","text":" as a dependency for our executable target."},{"text":" ","type":"text"},{"type":"text","text":"Our “Package.swift” file ends up looking like this:"}],"type":"paragraph"},{"code":["\/\/ swift-tools-version:5.5","import PackageDescription","","let package = Package(","    name: \"Count\",","    dependencies: [","        .package(url: \"https:\/\/github.com\/apple\/swift-argument-parser.git\", from: \"1.2.0\"),","    ],","    targets: [","        .executableTarget(","            name: \"count\",","            dependencies: [.product(name: \"ArgumentParser\", package: \"swift-argument-parser\")]),","    ]",")"],"type":"codeListing","syntax":"swift"},{"text":"Building Our First Command","anchor":"Building-Our-First-Command","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Once we’ve built the "},{"code":"count","type":"codeVoice"},{"text":" tool, we’ll be able to run it like this:","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["% count readme.md readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"We’ll define the initial version of the command as a type that conforms to the "},{"code":"ParsableCommand","type":"codeVoice"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"code":["import ArgumentParser","","@main","struct Count: ParsableCommand {","    @Argument var inputFile: String","    @Argument var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above, the "},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" and "},{"code":"outputFile","type":"codeVoice"},{"text":" properties use the ","type":"text"},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":" property wrapper. "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" uses this wrapper to denote a positional command-line input — because "},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" is specified first in the "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" type, it’s the first value read from the command line, and "},{"code":"outputFile","type":"codeVoice"},{"type":"text","text":" is the second."}]},{"inlineContent":[{"text":"The command’s logic is implemented in its ","type":"text"},{"type":"codeVoice","code":"run()"},{"text":" method. Here, it prints out a message confirming the names of the files the user gave. (You can find a full implementation of the completed command at the end of this guide.)","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, the "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" command is designated as the program’s entry point by applying the "},{"type":"codeVoice","code":"@main"},{"type":"text","text":" attribute. When running your command, the "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" library parses the command-line arguments, verifies that they match up with what we’ve defined in "},{"code":"Count","type":"codeVoice"},{"type":"text","text":", and either calls the "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method or exits with a helpful message."}]},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"text":"The Swift compiler uses either the type marked with ","type":"text"},{"code":"@main","type":"codeVoice"},{"text":" or a ","type":"text"},{"type":"codeVoice","code":"main.swift"},{"type":"text","text":" file as the entry point for an executable program. You can use either one, but not both — rename your "},{"code":"main.swift","type":"codeVoice"},{"type":"text","text":" file to the name of the command when you add "},{"type":"codeVoice","code":"@main"},{"type":"text","text":". In this case, rename the file to "},{"code":"Count.swift","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"text":"Working with Named Options","level":2,"anchor":"Working-with-Named-Options","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Our ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" tool may have a usability problem — it’s not immediately clear whether a user should provide the input file first, or the output file. Instead of using positional arguments for our two inputs, let’s specify that they should be labeled options:","type":"text"}]},{"type":"codeListing","code":["% count --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"We do this by using the "},{"code":"@Option","type":"codeVoice"},{"text":" property wrapper instead of ","type":"text"},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":":"}]},{"syntax":"swift","type":"codeListing","code":["@main","struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" property wrapper denotes a command-line input that looks like "},{"type":"codeVoice","code":"--name <value>"},{"type":"text","text":", deriving its name from the name of your property."}]},{"type":"paragraph","inlineContent":[{"text":"This interface has a trade-off for the users of our ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" tool: With ","type":"text"},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":", users don’t need to type as much, but they have to remember whether to provide the input file or the output file first. Using "},{"code":"@Option","type":"codeVoice"},{"type":"text","text":" makes the user type a little more, but the distinction between values is explicit. Options are order-independent, as well, so the user can name the input and output files in either order:"}]},{"type":"codeListing","code":["% count --output-file readme.counts --input-file readme.md","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"syntax":null},{"text":"Adding a Flag","level":2,"type":"heading","anchor":"Adding-a-Flag"},{"inlineContent":[{"type":"text","text":"Next, we want to add a "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag to our tool, and only print the message if the user specifies that option:"}],"type":"paragraph"},{"code":["% count --input-file readme.md --output-file readme.counts","(no output)","% count --verbose --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing","syntax":null},{"inlineContent":[{"text":"Let’s change our ","type":"text"},{"type":"codeVoice","code":"Count"},{"type":"text","text":" type to look like this:"}],"type":"paragraph"},{"type":"codeListing","code":["@main","struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    @Flag var verbose = false","    ","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"@Flag","type":"codeVoice"},{"type":"text","text":" property wrapper denotes a command-line input that looks like "},{"code":"--name","type":"codeVoice"},{"text":", deriving its name from the name of your property. Flags are most frequently used for Boolean values, like the ","type":"text"},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" property here."}]},{"text":"Using Custom Names","anchor":"Using-Custom-Names","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can customize the names of our options and add an alternative to the "},{"code":"verbose","type":"codeVoice"},{"text":" flag so that users can specify ","type":"text"},{"type":"codeVoice","code":"-v"},{"type":"text","text":" instead of "},{"code":"--verbose","type":"codeVoice"},{"type":"text","text":". The new interface will look like this:"}]},{"code":["% count -v -i readme.md -o readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count --input readme.md --output readme.counts -v","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count -o readme.counts -i readme.md --verbose","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"Customize the input names by passing ","type":"text"},{"type":"codeVoice","code":"name"},{"type":"text","text":" parameters to the "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" initializers:"}]},{"syntax":"swift","type":"codeListing","code":["@main","struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")])","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")])","    var outputFile: String","","    @Flag(name: .shortAndLong)","    var verbose = false","    ","    mutating func run() throws { ... }","}"]},{"type":"paragraph","inlineContent":[{"text":"The default name specification is ","type":"text"},{"type":"codeVoice","code":".long"},{"text":", which uses a property’s name with a two-dash prefix. ","type":"text"},{"type":"codeVoice","code":".short"},{"type":"text","text":" uses only the first letter of a property’s name with a single-dash prefix, and allows combining groups of short options. You can specify custom short and long names with the "},{"code":".customShort(_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":".customLong(_:)","type":"codeVoice"},{"type":"text","text":" methods, respectively, or use the combined "},{"code":".shortAndLong","type":"codeVoice"},{"type":"text","text":" property to specify the common case of both the short and long derived names."}]},{"anchor":"Providing-Help","level":2,"text":"Providing Help","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ArgumentParser"},{"text":" automatically generates help for any command when a user provides the ","type":"text"},{"type":"codeVoice","code":"-h"},{"text":" or ","type":"text"},{"code":"--help","type":"codeVoice"},{"type":"text","text":" flags:"}]},{"type":"codeListing","syntax":null,"code":["% count --help","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>      ","  -o, --output <output>    ","  -v, --verbose            ","  -h, --help              Show help information."]},{"inlineContent":[{"text":"This is a great start — you can see that all the custom names are visible, and the help shows that values are expected for the ","type":"text"},{"code":"--input","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"--output"},{"type":"text","text":" options. However, our custom options and flag don’t have any descriptive text. Let’s add that now by passing string literals as the "},{"type":"codeVoice","code":"help"},{"type":"text","text":" parameter:"}],"type":"paragraph"},{"code":["@main","struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws { ... }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The help screen now includes descriptions for each parameter:"}]},{"syntax":null,"code":["% count -h","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>     A file to read. ","  -o, --output <output>   A file to save word counts to. ","  -v, --verbose           Print status updates while counting. ","  -h, --help              Show help information.",""],"type":"codeListing"},{"text":"The Complete Utility","type":"heading","anchor":"The-Complete-Utility","level":2},{"inlineContent":[{"type":"text","text":"As promised, here’s the complete "},{"type":"codeVoice","code":"count"},{"type":"text","text":" command, for your experimentation:"}],"type":"paragraph"},{"code":["import ArgumentParser","import Foundation","","@main","struct Count: ParsableCommand {","    static let configuration = CommandConfiguration(abstract: \"Word counter.\")","    ","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        guard let input = try? String(contentsOfFile: inputFile) else {","            throw RuntimeError(\"Couldn't read from '\\(inputFile)'!\")","        }","        ","        let words = input.components(separatedBy: .whitespacesAndNewlines)","            .map { word in","                word.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)","                    .lowercased()","            }","            .compactMap { word in word.isEmpty ? nil : word }","        ","        let counts = Dictionary(grouping: words, by: { $0 })","            .mapValues { $0.count }","            .sorted(by: { $0.value > $1.value })","        ","        if verbose {","            print(\"Found \\(counts.count) words.\")","        }","        ","        let output = counts.map { word, count in \"\\(word): \\(count)\" }","            .joined(separator: \"\\n\")","        ","        guard let _ = try? output.write(toFile: outputFile, atomically: true, encoding: .utf8) else {","            throw RuntimeError(\"Couldn't write to '\\(outputFile)'!\")","        }","    }","}","","struct RuntimeError: Error, CustomStringConvertible {","    var description: String","    ","    init(_ description: String) {","        self.description = description","    }","}"],"type":"codeListing","syntax":"swift"}]}],"abstract":[{"text":"Learn to set up and customize a simple command-line tool.","type":"text"}],"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"]]},"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/gettingstarted"]}],"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted"},"references":{"doc://ArgumentParser/documentation/ArgumentParser/AsyncParsableCommand":{"title":"AsyncParsableCommand","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","abstract":[{"type":"text","text":"A type that can be executed asynchronously, as part of a nested tree of"},{"type":"text","text":" "},{"text":"commands.","type":"text"}],"kind":"symbol","url":"\/documentation\/argumentparser\/asyncparsablecommand","role":"symbol","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"AsyncParsableCommand","kind":"identifier"}],"navigatorTitle":[{"text":"AsyncParsableCommand","kind":"identifier"}]},"doc://ArgumentParser/documentation/ArgumentParser/CustomizingCommandHelp":{"role":"article","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp","title":"Customizing Help for Commands","abstract":[{"type":"text","text":"Define your command’s abstract, extended discussion, or usage string, and set the flags used to invoke the help display."}],"type":"topic","url":"\/documentation\/argumentparser\/customizingcommandhelp","kind":"article"},"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol","type":"topic","url":"\/documentation\/argumentparser"},"doc://ArgumentParser/documentation/ArgumentParser/CommandsAndSubcommands":{"role":"article","abstract":[{"text":"Break complex command-line tools into a tree of subcommands.","type":"text"}],"title":"Defining Commands and Subcommands","type":"topic","url":"\/documentation\/argumentparser\/commandsandsubcommands","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","kind":"article"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"title":"ParsableCommand","type":"topic","abstract":[{"text":"A type that can be executed as part of a nested tree of commands.","type":"text"}],"role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"ParsableCommand","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"ParsableCommand"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","kind":"symbol","url":"\/documentation\/argumentparser\/parsablecommand"}}}