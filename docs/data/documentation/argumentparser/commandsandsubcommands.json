{"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","type":"heading","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"When command-line programs grow larger, it can be useful to divide them into a group of smaller programs, providing an interface through subcommands. Utilities such as ","type":"text"},{"type":"codeVoice","code":"git"},{"text":" and the Swift package manager are able to provide varied interfaces for each of their sub-functions by implementing subcommands such as ","type":"text"},{"type":"codeVoice","code":"git branch"},{"text":" or ","type":"text"},{"code":"swift package init","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generally, these subcommands each have their own configuration options, as well as options that are shared across several or all aspects of the larger program."}]},{"inlineContent":[{"type":"text","text":"You can build a program with commands and subcommands by defining multiple command types and specifying each command’s subcommands in its configuration. For example, here’s the interface of a "},{"type":"codeVoice","code":"math"},{"text":" utility that performs operations on a series of values given on the command line.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["% math add 10 15 7","32","% math multiply 10 15 7","1050","% math stats average 3 4 13 15 15","10.0","% math stats average --kind median 3 4 13 15 15","13.0","% math stats","OVERVIEW: Calculate descriptive statistics.","","USAGE: math stats <subcommand>","","OPTIONS:","  -h, --help              Show help information.","","SUBCOMMANDS:","  average                 Print the average of the values.","  stdev                   Print the standard deviation of the values.","  quantiles               Print the quantiles of the values (TBD).","","  See 'math help stats <subcommand>' for detailed help."],"syntax":null},{"inlineContent":[{"text":"Start by defining the root ","type":"text"},{"code":"Math","type":"codeVoice"},{"type":"text","text":" command. You can provide a static "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand\/configuration-35km1"},{"type":"text","text":" property for a command that specifies its subcommands and a default subcommand, if any."}],"type":"paragraph"},{"syntax":"swift","code":["struct Math: ParsableCommand {","    static var configuration = CommandConfiguration(","        abstract: \"A utility for performing maths.\",","        subcommands: [Add.self, Multiply.self, Statistics.self],","        defaultSubcommand: Add.self)","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"code":"Math","type":"codeVoice"},{"text":" lists its three subcommands by their types; we’ll see the definitions of ","type":"text"},{"type":"codeVoice","code":"Add"},{"text":", ","type":"text"},{"code":"Multiply","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Statistics","type":"codeVoice"},{"text":" below. ","type":"text"},{"code":"Add","type":"codeVoice"},{"type":"text","text":" is also given as a default subcommand — this means that it is selected if a user leaves out a subcommand name:"}]},{"syntax":null,"code":["% math 10 15 7","32"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, define a "},{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","type":"reference","isActive":true},{"text":" type with properties that will be shared across multiple subcommands. Types that conform to ","type":"text"},{"code":"ParsableArguments","type":"codeVoice"},{"type":"text","text":" can be parsed from command-line arguments, but don’t provide any execution through a "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, the "},{"type":"codeVoice","code":"Options"},{"text":" type accepts a ","type":"text"},{"code":"--hexadecimal-output","type":"codeVoice"},{"text":" flag and expects a list of integers.","type":"text"}]},{"syntax":"swift","code":["struct Options: ParsableArguments {","    @Flag(name: [.long, .customShort(\"x\")], help: \"Use hexadecimal notation for the result.\")","    var hexadecimalOutput = false","","    @Argument(help: \"A group of integers to operate on.\")","    var values: [Int]","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"It’s time to define our first two subcommands: "},{"code":"Add","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Multiply"},{"type":"text","text":". Both of these subcommands include the arguments defined in the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type by denoting that property with the "},{"code":"@OptionGroup","type":"codeVoice"},{"text":" property wrapper (see ","type":"text"},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","isActive":true},{"type":"text","text":"). "},{"type":"codeVoice","code":"@OptionGroup"},{"type":"text","text":" doesn’t define any new arguments for a command; instead, it splats in the arguments defined by another "},{"code":"ParsableArguments","type":"codeVoice"},{"type":"text","text":" type."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension Math {","    struct Add: ParsableCommand {","        static var configuration","            = CommandConfiguration(abstract: \"Print the sum of the values.\")","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(0, +)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","","    struct Multiply: ParsableCommand {","        static var configuration","            = CommandConfiguration(abstract: \"Print the product of the values.\")","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(1, *)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we’ll define "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":", the third subcommand of "},{"code":"Math","type":"codeVoice"},{"type":"text","text":". The "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":" command specifies a custom command name ("},{"code":"stats","type":"codeVoice"},{"text":") in its configuration, overriding the default derived from the type name (","type":"text"},{"type":"codeVoice","code":"statistics"},{"text":"). It also declares two additional subcommands, meaning that it acts as a forked branch in the command tree, and not a leaf.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["extension Math {","    struct Statistics: ParsableCommand {","        static var configuration = CommandConfiguration(","            commandName: \"stats\",","            abstract: \"Calculate descriptive statistics.\",","            subcommands: [Average.self, StandardDeviation.self])","    }","}"]},{"inlineContent":[{"type":"text","text":"Let’s finish our subcommands with the "},{"code":"Average","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"StandardDeviation"},{"type":"text","text":" types. Each of them has slightly different arguments, so they don’t use the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type defined above. Each subcommand is ultimately independent and can specify a combination of shared and unique arguments."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension Math.Statistics {","    struct Average: ParsableCommand {","        static var configuration = CommandConfiguration(","            abstract: \"Print the average of the values.\")","","        enum Kind: String, ExpressibleByArgument {","            case mean, median, mode","        }","","        @Option(help: \"The kind of average to provide.\")","        var kind: Kind = .mean","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        func calculateMean() -> Double { ... }","        func calculateMedian() -> Double { ... }","        func calculateMode() -> [Double] { ... }","","        mutating func run() {","            switch kind {","            case .mean:","                print(calculateMean())","            case .median:","                print(calculateMedian())","            case .mode:","                let result = calculateMode()","                    .map(String.init(describing:))","                    .joined(separator: \" \")","                print(result)","            }","        }","    }","","    struct StandardDeviation: ParsableCommand {","        static var configuration = CommandConfiguration(","            commandName: \"stdev\",","            abstract: \"Print the standard deviation of the values.\")","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        mutating func run() {","            if values.isEmpty {","                print(0.0)","            } else {","                let sum = values.reduce(0, +)","                let mean = sum \/ Double(values.count)","                let squaredErrors = values","                    .map { $0 - mean }","                    .map { $0 * $0 }","                let variance = squaredErrors.reduce(0, +) \/ Double(values.count)","                let result = variance.squareRoot()","                print(result)","            }","        }","    }","}"]},{"inlineContent":[{"type":"text","text":"Last but not least, we add the "},{"code":"@main","type":"codeVoice"},{"type":"text","text":" attribute to the root of our command tree, to tell the compiler to use that as the program’s entry point. Upon execution, this parses the command-line arguments, determines whether a subcommand was selected, and then instantiates and calls the "},{"type":"codeVoice","code":"run()"},{"text":" method on that particular subcommand.","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"The Swift compiler uses either the type marked with "},{"type":"codeVoice","code":"@main"},{"type":"text","text":" or a "},{"type":"codeVoice","code":"main.swift"},{"text":" file as the entry point for an executable program. You can use either one, but not both — rename your ","type":"text"},{"type":"codeVoice","code":"main.swift"},{"type":"text","text":" file to the name of your command when you add "},{"type":"codeVoice","code":"@main"},{"text":". In this case, rename it to ","type":"text"},{"code":"Math.swift","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside","style":"note","name":"Note"},{"type":"codeListing","code":["@main","struct Math: ParsableCommand {","    \/\/ ...","}"],"syntax":"swift"},{"inlineContent":[{"text":"That’s it for this doubly-nested ","type":"text"},{"type":"codeVoice","code":"math"},{"type":"text","text":" command! This example is also provided as a part of the "},{"code":"swift-argument-parser","type":"codeVoice"},{"text":" repository, so you can see it all together and experiment with it ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}]}],"abstract":[{"type":"text","text":"Break complex command-line tools into a tree of subcommands."}],"metadata":{"roleHeading":"Article","role":"article","modules":[{"name":"ArgumentParser"}],"title":"Defining Commands and Subcommands"},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp"],"generated":true}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/commandsandsubcommands"]}],"kind":"article","hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"],["doc:\/\/ArgumentParser\/documentation\/ArgumentParser","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand"]]},"sections":[],"identifier":{"url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","interfaceLanguage":"swift"},"schemaVersion":{"major":0,"patch":0,"minor":3},"references":{"doc://ArgumentParser/documentation/ArgumentParser/GettingStarted":{"role":"article","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","title":"Getting Started with ArgumentParser","abstract":[{"type":"text","text":"Learn to set up and customize a simple command-line tool."}],"type":"topic","url":"\/documentation\/argumentparser\/gettingstarted","kind":"article"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand/configuration-35km1":{"type":"topic","role":"symbol","defaultImplementations":1,"url":"\/documentation\/argumentparser\/parsablecommand\/configuration-35km1","required":true,"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"configuration"},{"kind":"text","text":": "},{"preciseIdentifier":"s:14ArgumentParser20CommandConfigurationV","text":"CommandConfiguration","kind":"typeIdentifier"}],"abstract":[{"type":"text","text":"Configuration for this command, including subcommands and custom help"},{"type":"text","text":" "},{"text":"text.","type":"text"}],"title":"configuration","kind":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand\/configuration-35km1"},"doc://ArgumentParser/documentation/ArgumentParser/CustomizingCommandHelp":{"role":"article","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp","title":"Customizing Help for Commands","abstract":[{"type":"text","text":"Define your command’s abstract, extended discussion, or usage string, and set the flags used to invoke the help display."}],"type":"topic","url":"\/documentation\/argumentparser\/customizingcommandhelp","kind":"article"},"https://github.com/apple/swift-argument-parser/blob/main/Examples/math/Math.swift":{"identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift","type":"link","titleInlineContent":[{"text":"here","type":"text"}],"title":"here","url":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift"},"doc://ArgumentParser/documentation/ArgumentParser/OptionGroup":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"OptionGroup","kind":"identifier"}],"url":"\/documentation\/argumentparser\/optiongroup","kind":"symbol","role":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","navigatorTitle":[{"kind":"identifier","text":"OptionGroup"}],"abstract":[{"type":"text","text":"A wrapper that transparently includes a parsable type."}],"title":"OptionGroup","type":"topic"},"doc://ArgumentParser/documentation/ArgumentParser/AsyncParsableCommand":{"title":"AsyncParsableCommand","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","abstract":[{"type":"text","text":"A type that can be executed asynchronously, as part of a nested tree of"},{"type":"text","text":" "},{"text":"commands.","type":"text"}],"kind":"symbol","url":"\/documentation\/argumentparser\/asyncparsablecommand","role":"symbol","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"AsyncParsableCommand","kind":"identifier"}],"navigatorTitle":[{"text":"AsyncParsableCommand","kind":"identifier"}]},"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol","type":"topic","url":"\/documentation\/argumentparser"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"title":"ParsableCommand","type":"topic","abstract":[{"text":"A type that can be executed as part of a nested tree of commands.","type":"text"}],"role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"ParsableCommand","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"ParsableCommand"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","kind":"symbol","url":"\/documentation\/argumentparser\/parsablecommand"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableArguments":{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","title":"ParsableArguments","abstract":[{"type":"text","text":"A type that can be parsed from a program’s command-line arguments."}],"kind":"symbol","url":"\/documentation\/argumentparser\/parsablearguments","role":"symbol","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ParsableArguments"}],"navigatorTitle":[{"kind":"identifier","text":"ParsableArguments"}]}}}