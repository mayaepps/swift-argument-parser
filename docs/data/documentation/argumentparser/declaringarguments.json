{"seeAlsoSections":[{"generated":true,"title":"Arguments, Options, and Flags","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments"]}],"abstract":[{"type":"text","text":"Use the "},{"code":"@Argument","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property wrappers to declare the command-line interface for your command."}],"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"]]},"kind":"article","metadata":{"role":"article","title":"Declaring Arguments, Options, and Flags","roleHeading":"Article","modules":[{"name":"ArgumentParser"}]},"schemaVersion":{"patch":0,"minor":3,"major":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"inlineContent":[{"text":"When creating commands, you can define three primary kinds of command-line inputs:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Arguments"}]},{"text":" are values given by a user and are read in order from first to last (see ","type":"text"},{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","type":"reference","isActive":true},{"text":"). For example, this command is called with three file names as arguments:","type":"text"}]},{"code":["% example file1.swift file2.swift file3.swift"],"type":"codeListing","syntax":null}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Options"}]},{"text":" are named key-value pairs. Keys start with one or two dashes (","type":"text"},{"type":"codeVoice","code":"-"},{"text":" or ","type":"text"},{"code":"--","type":"codeVoice"},{"text":"), and a user can separate the key and value with an equal sign (","type":"text"},{"type":"codeVoice","code":"="},{"text":") or a space (see ","type":"text"},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option","isActive":true},{"type":"text","text":"). This command is called with two options:"}]},{"type":"codeListing","syntax":null,"code":["% example --count=5 --index 2"]}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Flags","type":"text"}]},{"text":" are like options, but without a paired value. Instead, their presence indicates a particular value (see ","type":"text"},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag","isActive":true},{"type":"text","text":"). This command is called with two flags:"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example --verbose --strip-whitespace"]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The three preceding examples could be calls of this "},{"type":"codeVoice","code":"Example"},{"type":"text","text":" command:"}],"type":"paragraph"},{"code":["struct Example: ParsableCommand {","    @Argument var files: [String] = []","    @Option var count: Int?","    @Option var index = 0","    @Flag var verbose = false","    @Flag var stripWhitespace = false","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example shows how "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" provides defaults that speed up your initial development process:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Option and flag names are derived from the names of your command’s properties."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"What kinds of inputs are valid, and whether arguments are required, is based on your properties’ types and default values."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"In this example, all of the properties have default values (optional properties default to ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":").","type":"text"}]},{"inlineContent":[{"text":"Users must provide values for all properties with no implicit or specified default. For example, this command would require one integer argument and a string with the key ","type":"text"},{"type":"codeVoice","code":"--user-name"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Option var userName: String","    @Argument var value: Int","}"],"syntax":"swift"},{"inlineContent":[{"text":"When called without both values, the command exits with an error:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example 5","Error: Missing '--user-name <user-name>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information.","% example --user-name kjohnson","Error: Missing '<value>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information."]},{"inlineContent":[{"text":"When providing a default value for an array property, any user-supplied values replace the entire default.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Lucky: ParsableCommand {","    @Argument var numbers = [7, 14, 21]","","    mutating func run() throws {","        print(\"\"\"","        Your lucky numbers are:","        \\(numbers.map(String.init).joined(separator: \" \"))","        \"\"\")","    }","}"]},{"code":["% lucky ","Your lucky numbers are:","7 14 21","% lucky 1 2 3","Your lucky numbers are:","1 2 3"],"type":"codeListing","syntax":null},{"level":2,"type":"heading","anchor":"Customizing-option-and-flag-names","text":"Customizing option and flag names"},{"type":"paragraph","inlineContent":[{"text":"By default, options and flags derive the name that you use on the command line from the name of the property, such as ","type":"text"},{"code":"--count","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"--index"},{"type":"text","text":". Camel-case names are converted to lowercase with hyphen-separated words, like "},{"type":"codeVoice","code":"--strip-whitespace"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"You can override this default by specifying one or more name specifications in the "},{"code":"@Option","type":"codeVoice"},{"type":"text","text":" or "},{"code":"@Flag","type":"codeVoice"},{"text":" initializers. This command demonstrates the four name specifications:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(name: .long)  \/\/ Same as the default","    var stripWhitespace = false","","    @Flag(name: .short)","    var verbose = false","","    @Option(name: .customLong(\"count\"))","    var iterationCount: Int","","    @Option(name: [.customShort(\"I\"), .long])","    var inputFile: String","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Specifying "},{"code":".long","type":"codeVoice"},{"text":" or ","type":"text"},{"type":"codeVoice","code":".short"},{"text":" uses the property’s name as the source of the command-line name. Long names use the whole name, prefixed by two dashes, while short names are a single character prefixed by a single dash. In this example, the ","type":"text"},{"code":"stripWhitespace","type":"codeVoice"},{"type":"text","text":" and "},{"code":"verbose","type":"codeVoice"},{"type":"text","text":" flags are specified in this way:"}]},{"type":"codeListing","syntax":null,"code":["% example --strip-whitespace -v"]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Specifying ","type":"text"},{"type":"codeVoice","code":".customLong(_:)"},{"text":" or ","type":"text"},{"type":"codeVoice","code":".customShort(_:)"},{"type":"text","text":" uses the given string or character as the long or short name for the property."}]},{"syntax":null,"code":["% example --count 10 -I file1.swift"],"type":"codeListing"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use array literal syntax to specify multiple names. The ","type":"text"},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" property can alternatively be given with the default long name:"}]},{"syntax":null,"code":["% example --input-file file1.swift"],"type":"codeListing"}]}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Note:"}],"type":"strong"},{"text":" You can also pass ","type":"text"},{"type":"codeVoice","code":"withSingleDash: true"},{"text":" to ","type":"text"},{"code":".customLong","type":"codeVoice"},{"type":"text","text":" to create a single-dash flag or option, such as "},{"type":"codeVoice","code":"-verbose"},{"type":"text","text":". Use this name specification only when necessary, such as when migrating a legacy command-line interface. Using long names with a single-dash prefix can lead to ambiguity with combined short names: it may not be obvious whether "},{"code":"-file","type":"codeVoice"},{"text":" is a single option or the combination of the four short options ","type":"text"},{"code":"-f","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"-i"},{"type":"text","text":", "},{"code":"-l","type":"codeVoice"},{"type":"text","text":", and "},{"code":"-e","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"level":2,"text":"Parsing custom types","anchor":"Parsing-custom-types","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Arguments and options can be parsed from any type that conforms to the ","type":"text"},{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument","isActive":true,"type":"reference"},{"type":"text","text":" protocol. Standard library integer and floating-point types, strings, and Booleans all conform to "},{"type":"codeVoice","code":"ExpressibleByArgument"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can make your own custom types conform to "},{"code":"ExpressibleByArgument","type":"codeVoice"},{"type":"text","text":" by implementing "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)","isActive":true},{"text":":","type":"text"}]},{"code":["struct Path: ExpressibleByArgument {","    var pathString: String","","    init?(argument: String) {","        self.pathString = argument","    }","}","","struct Example: ParsableCommand {","    @Argument var inputFile: Path","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library provides a default implementation for "},{"type":"codeVoice","code":"RawRepresentable"},{"text":" types, like string-backed enumerations, so you only need to declare conformance.","type":"text"}]},{"code":["enum ReleaseMode: String, ExpressibleByArgument {","    case debug, release","}","","struct Example: ParsableCommand {","    @Option var mode: ReleaseMode","","    mutating func run() throws {","        print(mode)","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The user can provide the raw values on the command line, which are then converted to your custom type. Only valid values are allowed:","type":"text"}]},{"syntax":null,"type":"codeListing","code":["% example --mode release","release","% example --mode future","Error: The value 'future' is invalid for '--mode <mode>'"]},{"type":"paragraph","inlineContent":[{"text":"To use a non-","type":"text"},{"code":"ExpressibleByArgument","type":"codeVoice"},{"text":" type for an argument or option, you can instead provide a throwing ","type":"text"},{"code":"transform","type":"codeVoice"},{"text":" function that converts the parsed string to your desired type. This is a good idea for custom types that are more complex than a ","type":"text"},{"type":"codeVoice","code":"RawRepresentable"},{"text":" type, or for types you don’t define yourself.","type":"text"}]},{"syntax":"swift","code":["enum Format {","    case text","    case other(String)","","    init(_ string: String) throws {","        if string == \"text\" {","            self = .text","        } else {","            self = .other(string)","        }","    }","}","","struct Example: ParsableCommand {","    @Argument(transform: Format.init)","    var format: Format","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Throw an error from the "},{"code":"transform","type":"codeVoice"},{"type":"text","text":" function to indicate that the user provided an invalid value for that type. See "},{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation","type":"reference","isActive":true},{"text":" for more about customizing ","type":"text"},{"code":"transform","type":"codeVoice"},{"type":"text","text":" function errors."}]},{"type":"heading","text":"Using flag inversions, enumerations, and counts","level":2,"anchor":"Using-flag-inversions-enumerations-and-counts"},{"type":"paragraph","inlineContent":[{"text":"Flags are most frequently used for ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" properties. You can generate a ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":"\/"},{"code":"false","type":"codeVoice"},{"text":" pair of flags by specifying a flag inversion:","type":"text"}]},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag(inversion: .prefixedNo)","    var index = true","","    @Flag(inversion: .prefixedEnableDisable)","    var requiredElement: Bool","","    mutating func run() throws {","        print(index, requiredElement)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"When declaring a flag with an inversion, set the default by specifying ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":" or "},{"type":"codeVoice","code":"false"},{"type":"text","text":" as the property’s initial value. If you want to require that the user specify one of the two inversions, leave off the default value."}]},{"type":"paragraph","inlineContent":[{"text":"In the ","type":"text"},{"code":"Example","type":"codeVoice"},{"type":"text","text":" command defined above, a flag is required for the "},{"code":"requiredElement","type":"codeVoice"},{"text":" property. The specified prefixes are prepended to the long names for the flags:","type":"text"}]},{"syntax":null,"code":["% example --enable-required-element","true true","% example --no-index --disable-required-element","false false","% example --index","Error: Missing one of: '--enable-required-element', '--disable-required-element'"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To create a flag with custom names for a Boolean value, to provide an exclusive choice between more than two names, or for collecting multiple values from a set of defined choices, define an enumeration that conforms to the "},{"type":"codeVoice","code":"EnumerableFlag"},{"type":"text","text":" protocol."}]},{"syntax":"swift","code":["enum CacheMethod: String, EnumerableFlag {","    case inMemoryCache","    case persistentCache","}","","enum Color: String, EnumerableFlag {","    case pink, purple, silver","}","","struct Example: ParsableCommand {","    @Flag var cacheMethod: CacheMethod","    @Flag var colors: [Color] = []","","    mutating func run() throws {","        print(cacheMethod)","        print(colors)","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The flag names in this case are drawn from the raw values — for information about customizing the names and help text, see the  "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag","isActive":true},{"type":"text","text":" documentation."}]},{"type":"codeListing","syntax":null,"code":["% example --in-memory-cache --pink --silver",".inMemoryCache","[.pink, .silver]","% example","Error: Missing one of: '--in-memory-cache', '--persistent-cache'"]},{"inlineContent":[{"type":"text","text":"Finally, when a flag is of type "},{"code":"Int","type":"codeVoice"},{"text":", the value is parsed as a count of the number of times that the flag is specified.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(name: .shortAndLong)","    var verbose: Int","","    mutating func run() throws {","        print(\"Verbosity level: \\(verbose)\")","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, "},{"type":"codeVoice","code":"verbose"},{"text":" defaults to zero, and counts the number of times that ","type":"text"},{"code":"-v","type":"codeVoice"},{"type":"text","text":" or "},{"code":"--verbose","type":"codeVoice"},{"text":" is given.","type":"text"}]},{"syntax":null,"type":"codeListing","code":["% example --verbose","Verbosity level: 1","% example -vvvv","Verbosity level: 4"]},{"type":"heading","level":2,"anchor":"Specifying-default-values","text":"Specifying default values"},{"inlineContent":[{"type":"text","text":"You can specify default values for almost all supported argument, option, and flag types using normal property initialization syntax:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["enum CustomFlag: String, EnumerableFlag {","    case foo, bar, baz","}","","struct Example: ParsableCommand {","    @Flag","    var booleanFlag = false","","    @Flag","    var arrayFlag: [CustomFlag] = [.foo, .baz]","","    @Option","    var singleOption = 0","","    @Option","    var arrayOption = [\"bar\", \"qux\"]","","    @Argument","    var singleArgument = \"quux\"","","    @Argument","    var arrayArgument = [\"quux\", \"quuz\"]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This includes all of the variants of the argument types above (including "},{"code":"@Option(transform: ...)","type":"codeVoice"},{"text":", etc.), with a few notable exceptions:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"Optional"},{"type":"text","text":"-typed values (which default to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" and for which a default would not make sense, as the value could never be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"Int","type":"codeVoice"},{"text":" flags (which are used for counting the number of times a flag is specified and therefore default to ","type":"text"},{"type":"codeVoice","code":"0"},{"type":"text","text":")"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a default is not specified, the user must provide a value for that argument\/option\/flag or will receive an error that the value is missing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You must also always specify a default of "},{"type":"codeVoice","code":"false"},{"text":" for a non-optional ","type":"text"},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" flag, as in the example above. This makes the behavior consistent with both normal Swift properties (which either must be explicitly initialized or optional to initialize a "},{"type":"codeVoice","code":"struct"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"class"},{"text":" containing them) and the other property types.","type":"text"}]},{"type":"heading","anchor":"Specifying-a-parsing-strategy","text":"Specifying a parsing strategy","level":2},{"type":"paragraph","inlineContent":[{"text":"When parsing a list of command-line inputs, ","type":"text"},{"code":"ArgumentParser","type":"codeVoice"},{"type":"text","text":" distinguishes between dash-prefixed keys and un-prefixed values. When looking for the value for a key, only an un-prefixed value will be selected by default."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, this command defines a "},{"code":"--verbose","type":"codeVoice"},{"text":" flag, a ","type":"text"},{"type":"codeVoice","code":"--name"},{"type":"text","text":" option, and an optional "},{"type":"codeVoice","code":"file"},{"type":"text","text":" argument:"}]},{"code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Option var name: String","    @Argument var file: String?","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), name: \\(name), file: \\(file ?? \"none\")\")","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"When calling this command, the value for ","type":"text"},{"type":"codeVoice","code":"--name"},{"type":"text","text":" must be given immediately after the key. If the "},{"code":"--verbose","type":"codeVoice"},{"type":"text","text":" flag is placed in between, parsing fails with an error:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose --name Tomás","Verbose: true, name: Tomás, file: none","% example --name --verbose Tomás","Error: Missing value for '--name <name>'","Usage: example [--verbose] --name <name> [<file>]","  See 'example --help' for more information."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Parsing options as arrays is similar — only adjacent key-value pairs are recognized by default."}]},{"anchor":"Alternative-single-value-parsing-strategies","level":3,"text":"Alternative single-value parsing strategies","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can change this behavior by providing a different parsing strategy in the "},{"code":"@Option","type":"codeVoice"},{"type":"text","text":" initializer. "},{"inlineContent":[{"text":"Be careful when selecting any of the alternative parsing strategies","type":"text"}],"type":"strong"},{"text":" — they may lead your command-line tool to have unexpected behavior for users!","type":"text"}]},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".unconditional"},{"type":"text","text":" parsing strategy uses the immediate next input for the value of the option, even if it starts with a dash. If "},{"code":"name","type":"codeVoice"},{"text":" were instead defined as ","type":"text"},{"code":"@Option(parsing: .unconditional) var name: String","type":"codeVoice"},{"type":"text","text":", the second attempt would result in "},{"type":"codeVoice","code":"\"--verbose\""},{"type":"text","text":" being read as the value of "},{"type":"codeVoice","code":"name"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example --name --verbose Tomás","Verbose: false, name: --verbose, file: Tomás"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".scanningForValue"},{"text":" strategy, on the other hand, looks ahead in the list of command-line inputs and uses the first un-prefixed value as the input, even if that requires skipping over other flags or options.  If ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" were defined as ","type":"text"},{"type":"codeVoice","code":"@Option(parsing: .scanningForValue) var name: String"},{"text":", the parser would look ahead to find ","type":"text"},{"type":"codeVoice","code":"Tomás"},{"type":"text","text":", then pick up parsing where it left off to get the "},{"type":"codeVoice","code":"--verbose"},{"text":" flag:","type":"text"}]},{"code":["% example --name --verbose Tomás","Verbose: true, name: Tomás, file: none"],"type":"codeListing","syntax":null},{"type":"heading","anchor":"Alternative-array-parsing-strategies","level":3,"text":"Alternative array parsing strategies"},{"type":"paragraph","inlineContent":[{"text":"The default strategy for parsing options as arrays is to read each value from a key-value pair. For example, this command expects zero or more input file names:","type":"text"}]},{"syntax":"swift","code":["struct Example: ParsableCommand {","    @Option var file: [String] = []","    @Flag var verbose = false","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(file)\")","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"As with single values, each time the user provides the "},{"type":"codeVoice","code":"--file"},{"text":" key, they must also provide a value:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["% example --verbose --file file1.swift --file file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file --verbose file1.swift --file file2.swift","Error: Missing value for '--file <file>'","Usage: example [--file <file> ...] [--verbose]","  See 'example --help' for more information."],"syntax":null},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".unconditionalSingleValue"},{"text":" parsing strategy uses whatever input follows the key as its value, even if that input is dash-prefixed. If ","type":"text"},{"type":"codeVoice","code":"file"},{"type":"text","text":" were defined as "},{"code":"@Option(parsing: .unconditionalSingleValue) var file: [String]","type":"codeVoice"},{"type":"text","text":", then the resulting array could include strings that look like options:"}],"type":"paragraph"},{"syntax":null,"code":["% example --file file1.swift --file --verbose","Verbose: false, files: [\"file1.swift\", \"--verbose\"]"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".upToNextOption"},{"type":"text","text":" parsing strategy uses the inputs that follow the option key until reaching a dash-prefixed input. If "},{"type":"codeVoice","code":"file"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Option(parsing: .upToNextOption) var file: [String]"},{"type":"text","text":", then the user could specify multiple files without repeating "},{"type":"codeVoice","code":"--file"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["% example --file file1.swift file2.swift","Verbose: false, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"Finally, the ","type":"text"},{"type":"codeVoice","code":".remaining"},{"text":" parsing strategy uses all the inputs that follow the option key, regardless of their prefix. If ","type":"text"},{"code":"file","type":"codeVoice"},{"text":" were defined as ","type":"text"},{"type":"codeVoice","code":"@Option(parsing: .remaining) var file: [String]"},{"type":"text","text":", then the user would need to specify "},{"code":"--verbose","type":"codeVoice"},{"type":"text","text":" before the "},{"type":"codeVoice","code":"--file"},{"text":" key for it to be recognized as a flag:","type":"text"}]},{"syntax":null,"code":["% example --verbose --file file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: false, files: [\"file1.swift\", \"file2.swift\", \"--verbose\"]"],"type":"codeListing"},{"level":3,"type":"heading","anchor":"Alternative-positional-argument-parsing-strategies","text":"Alternative positional argument parsing strategies"},{"inlineContent":[{"type":"text","text":"The default strategy for parsing arrays of positional arguments is to ignore  all dash-prefixed command-line inputs. For example, this command accepts a "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag and a list of file names as positional arguments:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Argument var files: [String] = []","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(files)\")","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"files"},{"type":"text","text":" argument array uses the default "},{"type":"codeVoice","code":".remaining"},{"type":"text","text":" parsing strategy, so it only picks up values that don’t have a prefix:"}]},{"syntax":null,"code":["% example --verbose file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --verbose file1.swift file2.swift --other","Error: Unexpected argument '--other'","Usage: example [--verbose] [<files> ...]","  See 'example --help' for more information."],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any input after the "},{"code":"--","type":"codeVoice"},{"text":" terminator is automatically treated as positional input, so users can provide dash-prefixed values that way even with the default configuration:","type":"text"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose -- file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]"]},{"inlineContent":[{"type":"text","text":"The "},{"code":".unconditionalRemaining","type":"codeVoice"},{"text":" parsing strategy uses whatever input is left after parsing known options and flags, even if that input is dash-prefixed, including the terminator itself. If ","type":"text"},{"type":"codeVoice","code":"files"},{"type":"text","text":" were defined as "},{"code":"@Argument(parsing: .unconditionalRemaining) var files: [String]","type":"codeVoice"},{"type":"text","text":", then the resulting array would also include strings that look like options:"}],"type":"paragraph"},{"type":"codeListing","code":["% example --verbose file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]","% example -- --verbose file1.swift file2.swift --other","Verbose: false, files: [\"--\", \"--verbose\", \"file1.swift\", \"file2.swift\", \"--other\"]"],"syntax":null}]}],"variants":[{"paths":["\/documentation\/argumentparser\/declaringarguments"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/DeclaringArguments","interfaceLanguage":"swift"},"references":{"doc://ArgumentParser/documentation/ArgumentParser/OptionGroup":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"OptionGroup","kind":"identifier"}],"url":"\/documentation\/argumentparser\/optiongroup","kind":"symbol","role":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","navigatorTitle":[{"kind":"identifier","text":"OptionGroup"}],"abstract":[{"type":"text","text":"A wrapper that transparently includes a parsable type."}],"title":"OptionGroup","type":"topic"},"doc://ArgumentParser/documentation/ArgumentParser/Flag":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Flag","kind":"identifier"}],"url":"\/documentation\/argumentparser\/flag","kind":"symbol","role":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag","navigatorTitle":[{"kind":"identifier","text":"Flag"}],"abstract":[{"type":"text","text":"A property wrapper that represents a command-line flag."}],"title":"Flag","type":"topic"},"doc://ArgumentParser/documentation/ArgumentParser/Validation":{"title":"Providing Custom Validation","url":"\/documentation\/argumentparser\/validation","abstract":[{"type":"text","text":"Provide helpful feedback to users when things go wrong."}],"type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation","kind":"article","role":"article"},"doc://ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument":{"type":"topic","url":"\/documentation\/argumentparser\/expressiblebyargument","abstract":[{"text":"A type that can be expressed as a command-line argument.","type":"text"}],"kind":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ExpressibleByArgument","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"ExpressibleByArgument"}],"title":"ExpressibleByArgument"},"doc://ArgumentParser/documentation/ArgumentParser/EnumerableFlag":{"kind":"symbol","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EnumerableFlag"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag","role":"symbol","title":"EnumerableFlag","abstract":[{"text":"A type that represents the different possible flags to be used by a","type":"text"},{"type":"text","text":" "},{"code":"@Flag","type":"codeVoice"},{"text":" property.","type":"text"}],"url":"\/documentation\/argumentparser\/enumerableflag","navigatorTitle":[{"kind":"identifier","text":"EnumerableFlag"}]},"doc://ArgumentParser/documentation/ArgumentParser/Option":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Option","kind":"identifier"}],"url":"\/documentation\/argumentparser\/option","kind":"symbol","role":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option","navigatorTitle":[{"text":"Option","kind":"identifier"}],"abstract":[{"type":"text","text":"A property wrapper that represents a command-line option."}],"title":"Option","type":"topic"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableArguments":{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","title":"ParsableArguments","abstract":[{"type":"text","text":"A type that can be parsed from a program’s command-line arguments."}],"kind":"symbol","url":"\/documentation\/argumentparser\/parsablearguments","role":"symbol","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ParsableArguments"}],"navigatorTitle":[{"kind":"identifier","text":"ParsableArguments"}]},"doc://ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument/init(argument:)":{"url":"\/documentation\/argumentparser\/expressiblebyargument\/init(argument:)","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)","required":true,"kind":"symbol","role":"symbol","fragments":[{"text":"init","kind":"identifier"},{"kind":"text","text":"?("},{"kind":"externalParam","text":"argument"},{"text":": ","kind":"text"},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"kind":"text","text":")"}],"type":"topic","abstract":[{"text":"Creates a new instance of this type from a command-line-specified","type":"text"},{"type":"text","text":" "},{"text":"argument.","type":"text"}],"title":"init(argument:)"},"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol","type":"topic","url":"\/documentation\/argumentparser"},"doc://ArgumentParser/documentation/ArgumentParser/Argument":{"title":"Argument","url":"\/documentation\/argumentparser\/argument","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A property wrapper that represents a positional command-line argument."}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Argument"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","navigatorTitle":[{"text":"Argument","kind":"identifier"}]}}}